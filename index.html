<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luca Baroni </title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Nunito:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #1a1a1a;
            --secondary-color: #4a4a4a;
            --accent-color: #0066cc;
            --background: #ffffff;
            --surface: #f8f9fa;
            --border: #e5e7eb;
            --text-primary: #1a1a1a;
            --text-secondary: #6b7280;
            --max-width: 800px;
            /* --particle-color: rgba(0, 102, 204, 0.4); */
            --particle-color: rgba(0, 0, 0, 1)
        }

        @media (prefers-color-scheme: dark) {
            :root {
            --primary-color: #ffffff;
            --secondary-color: #b8b8b8;
            --accent-color: #e2c6f7;
            --background: #0a0a0a;
                --surface: #1a1a1a;
            --border: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #9ca3af;
            --particle-color: rgb(255, 255, 255);
            }
        }

        body {
            font-family: 'Crimson Text', serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--background);
            transition: all 0.3s ease;
            position: relative;
            overflow-x: hidden;
        }

        #particles-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.7;
            z-index: -1;
        }

        .container {
            max-width: var(--max-width);
            margin: 0 auto;
            padding: 1.2rem 1.2rem 0.5rem 1.2rem;
            position: relative;
            z-index: 1;
            background: var(--background);
            border-radius: 12px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
        }

        header {
            margin-bottom: 1.2rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-family: 'Crimson Text', serif;
            font-size: 2.3rem;
            font-weight: 700;
            margin-bottom: 0.3rem;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-family: 'Crimson Text', serif;
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            font-weight: 300;
            letter-spacing: 0.02em;
        }

        nav {
            display: flex;
            gap: 1.2rem;
            margin-top: 1.2rem;
        }

        nav a {
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 500;
            position: relative;
            transition: color 0.3s ease;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        nav a:hover {
            color: var(--accent-color);
        }

        nav a.active::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            right: 0;
            height: 2px;
            background-color: var(--accent-color);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: scaleX(0);
            }
            to {
                transform: scaleX(1);
            }
        }

        .section {
            display: none;
            animation: fadeIn 0.4s ease;
            margin-bottom: 0.7rem;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            font-family: 'Crimson Text', serif;
            font-size: 1.5rem;
            margin-bottom: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        h3 {
            font-family: 'Crimson Text', serif;
            font-size: 1.1rem;
            margin-top: 1.2rem;
            margin-bottom: 0.7rem;
            font-weight: 700;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        .publication {
            line-height: 1.2;
            background-color: var(--surface);
            padding: 0.7rem 1.3rem 0.5rem 1rem;
            margin-bottom: 0.4rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .publication::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 102, 204, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .publication:hover::before {
            left: 100%;
        }

        .publication:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        }

        .publication[onclick] {
            cursor: pointer;
        }

        .publication[onclick]:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.15);
        }

        .publication-title {
            font-family: 'Crimson Text', serif;
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .publication-authors {
            color: var(--text-secondary);
            font-size: 0.95rem;
            margin-bottom: 0.5rem;
        }

        .publication-venue {
            color: var(--accent-color);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-style: italic;
        }

        .publication-links {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
        }

        .publication-links a {
            color: var(--accent-color);
            text-decoration: none;
            font-size: 0.85rem;
            padding: 0.35rem 1rem;
            border: 1px solid var(--accent-color);
            border-radius: 20px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 500;
        }

        .publication-links a:hover {
            background-color: var(--accent-color);
            color: var(--background);
            transform: translateY(-1px);
        }

        .cv-section {
            margin-bottom: 0.7rem;
        }

        .cv-item {
            margin-bottom: 0.4rem;
            padding-left: 1rem;
            border-left: 3px solid var(--accent-color);
            transition: border-color 0.3s ease;
        }

        .cv-item:hover {
            border-left-color: var(--text-primary);
        }

        .cv-date {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
            font-weight: 600;
            letter-spacing: 0.03em;
        }

        .cv-title {
            font-family: 'Crimson Text', serif;
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.25rem;
        }

        .cv-location {
            color: var(--text-secondary);
            font-style: italic;
        }

        .profile-section {
            display: flex;
            gap: 1.2rem;
            align-items: center;
            margin-bottom: 0.7rem;
        }

        .profile-image {
            flex-shrink: 0;
            width: 220px;
            height: 220px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid var(--border);
            transition: all 0.3s ease;
            position: relative;
        }

        .profile-image:hover {
            border-color: var(--accent-color);
            transform: scale(1.02);
        }

        .profile-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .profile-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--accent-color), var(--secondary-color));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 3rem;
            font-weight: 600;
        }

        .profile-content {
            flex: 1;
            font-family: 'Nunito', sans-serif;
        }
        
        .blog-post {
            margin-bottom: 0.6rem;
            padding-bottom: 0.6rem;
            border-bottom: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .blog-post:hover {
            padding-left: 1rem;
        }

        .blog-post:last-child {
            border-bottom: none;
        }

        .blog-date {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
        }

        .blog-title {
            font-family: 'Crimson Text', serif;
            font-size: 1.75rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            text-decoration: none;
            display: block;
            transition: color 0.3s ease;
        }

        .blog-title:hover {
            color: var(--accent-color);
        }

        .blog-excerpt {
            color: var(--text-secondary);
            line-height: 1.8;
            font-size: 0.95rem;
        }

        .contact-info {
            background-color: var(--surface);
            padding: 1.2rem 1.2rem 0.6rem 1.2rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            padding-bottom: 0.6rem;
        }

        .contact-section {
            display: flex;
            gap: 1.2rem;
            align-items: center;
        }

        .contact-image {
            flex-shrink: 0;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid var(--border);
            transition: all 0.3s ease;
        }

        .contact-image:hover {
            border-color: var(--accent-color);
            transform: scale(1.05);
        }

        .contact-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .contact-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--accent-color), var(--secondary-color));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2.5rem;
            font-weight: 600;
        }

        .contact-details {
            flex: 1;
        }

        .contact-details p {
            margin-bottom: 0.5rem;
        }

        .contact-info:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .contact-info a {
            color: var(--accent-color);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .contact-info a:hover {
            text-decoration: underline;
            padding-left: 0.5rem;
        }

        ul {
            margin-top: 1rem;
            margin-left: 2rem;
            color: var(--text-secondary);
        }

        ul li {
            margin-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0.7rem 0.7rem 0.3rem 0.7rem;
            }
            header {
                margin-bottom: 0.7rem;
                padding-bottom: 0.3rem;
            }
            .section {
                margin-bottom: 0.3rem;
            }
            .publication {
                margin-bottom: 0.2rem;
                padding-bottom: 0.2rem;
            }
            .cv-section {
                margin-bottom: 0.3rem;
            }
            .cv-item {
                margin-bottom: 0.2rem;
            }
            .blog-post {
                margin-bottom: 0.3rem;
                padding-bottom: 0.3rem;
            }
            .contact-info {
                padding-bottom: 0.3rem;
            }
            .profile-section, .contact-section {
                flex-direction: column;
                align-items: center;
                text-align: center;
                gap: 0.7rem;
                margin-bottom: 0.3rem;
            }
            .profile-image, .contact-image {
                width: 100px;
                height: 100px;
                margin-bottom: 0.7rem;
            }
            h1 {
                font-size: 1.5rem;
            }
            h2 {
                font-size: 1.2rem;
            }
            nav {
                gap: 0.7rem;
            }
            .publication-links {
                flex-wrap: wrap;
            }
            /* Change "curriculum vitae" to "cv" on mobile */
            nav a[href="#cv"] {
                font-size: 0;
            }
            nav a[href="#cv"]::before {
                content: "cv";
                font-size: 0.95rem;
            }
        }

        .publication-venue-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 1rem;
        }
        .publication-equal-note {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
            margin-top: 0;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <canvas id="particles-canvas"></canvas>
    
    <div class="container">
        <header>
            <h1>Luca Baroni</h1>
            <!-- <p class="subtitle">Computational Neuroscience & AI Safety</p> -->
            <nav>
                <a href="#about" class="nav-link active">About</a>
                <a href="#publications" class="nav-link">Publications</a>
                <a href="#cv" class="nav-link">curriculum vitae</a>
                <!-- <a href="#thoughts" class="nav-link">Thoughts</a> -->
                <a href="#contact" class="nav-link">Contact</a>
                <!-- <a href="#birds" class="nav-link" style="margin-left:auto;">hide me</a> -->
            </nav>
        </header>

        <main>
            <section id="about" class="section active">
                <!-- <h2>About me</h2> -->
                <div class="profile-section">
                    <div class="profile-image">
                        <!-- Replace src with your actual photo path -->
                        <img src="profile.jpg" alt="Luca Baroni" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        <div class="profile-placeholder" style="display:none;">LB</div>
                    </div>
                    <div class="profile-content">
                        <p><h2>Hi!</h2> </p>
                        <p>I'm Luca, a computational neuroscientist pursuing a PhD at Charles University. </p>
                        <!-- <p>My research focuses on modeling neural responses in the visual cortex using deep learning, uncovering computational mechanisms of sensory processing and developing stimulation strategies for cortical prostheses that more effectively engage visual representations to restore vision in blind individuals. </p> -->
                        <p>I study sensory processing in the visual cortex, aiming to uncover underlying computational principles and develop stimulation strategies for cortical prostheses that more effectively engage visual representations for vision restoration in blind individuals.</p> 
                        <p>Investigating how biological neural networks represent information, I becamed interested  in mechanistic interpretability of LLMs and, more broadly,  in  AI safety and alignment.</p>
                        <!-- <p>I'm a computational neuroscience researcher working at the intersection of machine learning, neuroscience, and vision restoration. My PhD research focuses on using deep learning to model neural responses in visual cortex and applying interpretability techniques to uncover computational mechanisms.</p>
                
                <p>Through my work, I've identified novel invariance properties in biological neurons and designed stimulation strategies for cortical prostheses that engage visual representation in the brain to restore vision in blind subjects. More recently, driven by a growing interest in AI safety, I participated in the Supervised Program for Alignment Research (SPAR), where I gained practical expertise in mechanistic interpretability of large language models.</p> -->
                    </div>
                </div>
                
                <!-- <p>My research interests include:</p>
                <ul>
                    <li>Neural network interpretability and mechanistic understanding</li>
                    <li>Computational models of visual cortex</li>
                    <li>Vision restoration through cortical prostheses</li>
                    <li>AI alignment and safety research</li>
                    <li>Invariance learning in biological and artificial neural systems</li>
                </ul> -->
            </section>

            <section id="publications" class="section">
                <h2>Peer-reviewed articles</h2>
                                <div id="publications-list">
                    <div style="text-align: center; color: var(--text-secondary); padding: 2rem;">
                        Loading publications...
                    </div>
                </div>
            </section>

            <section id="cv" class="section">
                <h2>Curriculum Vitae</h2>
                
                <div class="cv-section">
                    <h3>Education</h3>
                    <div class="cv-item">
                        <div class="cv-title">PhD in Computational Neuroscience</div>
                        <div class="cv-location">Charles University, Prague | Supervisor: Ján Antolík</div>
                        <div class="cv-date">2020 - Present</div>
                    </div>
                    <div class="cv-item">
                        <div class="cv-title">MSc in Theoretical Physics</div>
                        <div class="cv-location">University of Milan - Bicocca | Graduated with honors</div>
                        <div class="cv-date">2017 - 2020</div>
                    </div>
                    <div class="cv-item">
                        <div class="cv-title">BSc in Physics</div>
                        <div class="cv-location">University of Milan - Bicocca | Graduated with honors</div>
                        <div class="cv-date">2014 - 2017</div>
                    </div>
                </div>

                <div class="cv-section">
                    <h3>Research Experience</h3>
                    <div class="cv-item">
                        <div class="cv-title">SPAR (Supervised Program for Alignment Research)</div>
                        <div class="cv-location">AI Safety Research | Supervisor: Stefan Heimersheim</div>
                        <div class="cv-date">February 2025 - May 2025</div>
                    </div>
                    <div class="cv-item">
                        <div class="cv-title">PhD Research Secondment</div>
                        <div class="cv-location">Femtonics, Budapest</div>
                        <div class="cv-date">September 2022 - October 2022</div>
                    </div>
                    <div class="cv-item">
                        <div class="cv-title">PhD Research Secondment</div>
                        <div class="cv-location">Neuronal Intelligence Lab, Göttingen / Supervisor: Fabian H. Sinz</div>
                        <div class="cv-date">March 2022 - June 2022</div>
                    </div>
                    <div class="cv-item">
                        <div class="cv-title"> Internship</div>
                        <div class="cv-location">LIPh (Laboratory of Interdisciplinary Physics), Padua</div>
                        <div class="cv-date">October 2019 - April 2020</div>
                    </div>
                </div>

                <!-- <div class="cv-section">
                    <h3>Selected Talks</h3>
                    <div class="cv-item">
                        <div class="cv-title">Learning and aligning single neuron invariance manifolds in visual neurons</div>
                        <div class="cv-location">ICLR 2025 (Oral Presentation)</div>
                        <div class="cv-date">2025</div>
                    </div>
                    <div class="cv-item">
                        <div class="cv-title">Learning invariance manifolds of visual sensory neurons</div>
                        <div class="cv-location">46th Annual Conference of Japanese Neuroscience Society | Selected speaker</div>
                        <div class="cv-date">2023</div>
                    </div>
                    <div class="cv-item">
                       
                        <div class="cv-title">Invariances in primary visual cortex</div>
                        <div class="cv-location">Workshop on Physics of Data, Venice | Invited speaker</div> 
                        <div class="cv-date">2022</div>
                    </div>
                </div>

                <div class="cv-section">
                    <h3>Fellowship</h3>
                    <div class="cv-item">
                        <div class="cv-title">Marie Skłodowska-Curie Actions ITN Fellowship</div>
                        <div class="cv-location">enTRAIN Vision</div>
                    </div>
                </div> -->
            </section>

            <!-- <section id="thoughts" class="section">
                <h2>Personal Thoughts</h2>
                
                <div class="blog-post">
                    <div class="blog-date">March 15, 2024</div>
                    <a href="#" class="blog-title">The Convergence of Neuroscience and AI Safety</a>
                    <p class="blog-excerpt">Recent advances in understanding neural computation are providing crucial insights for building safer AI systems. In this post, I explore how principles from neuroscience can inform alignment research...</p>
                </div>

                <div class="blog-post">
                    <div class="blog-date">February 1, 2024</div>
                    <a href="#" class="blog-title">Interpretability Through the Lens of Biology</a>
                    <p class="blog-excerpt">What can we learn about neural network interpretability from biological neural systems? This post examines parallels between neuroscience methods and AI interpretability research...</p>
                </div>

                <div class="blog-post">
                    <div class="blog-date">December 10, 2023</div>
                    <a href="#" class="blog-title">Reflections on My PhD Journey</a>
                    <p class="blog-excerpt">As I near the completion of my doctoral studies, I wanted to share some thoughts on the research process, challenges faced, and lessons learned along the way...</p>
                </div>
            </section> -->

            <section id="contact" class="section">
                <!-- <h2>Contact</h2> -->
                <div class="contact-info">
                    <div class="contact-section">
                        <div class="contact-image">
                            <!-- Replace src with your actual photo path -->
                            <img src="profile.jpg" alt="Luca Baroni" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="contact-placeholder" style="display:none;">LB</div>
                        </div>
                        <div class="contact-details">
                    <p><strong>Email:</strong> <a href="mailto:loocabaroni@gmail.com">loocabaroni@gmail.com</a></p>
                    <p><strong>Location:</strong> Vienna, Austria</p>
                    <p><strong>GitHub:</strong> <a href="https://github.com/lucabaroni">GitHub Profile</a></p>
                    <p><strong>LinkedIn:</strong> <a href="https://www.linkedin.com/in/luca-baroni-261161157">LinkedIn Profile</a></p>
                    <p><strong>Research group:</strong> <a href="https://csng.mff.cuni.cz">CSNG webpage</a></p>
                            <!-- <a href="https://github.com/yourusername">GitHub</a></p>  <a href="https://linkedin.com/in/yourusername">LinkedIn</a></p> -->
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Navigation functionality
        const navLinks = document.querySelectorAll('.nav-link');
        const sections = document.querySelectorAll('.section');

        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                
                // Update active nav
                navLinks.forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                
                // Show target section
                sections.forEach(section => {
                    section.classList.remove('active');
                    if (section.id === targetId) {
                        section.classList.add('active');
                    }
                });
            });
        });

        // Bird flocking simulation
        const canvas = document.getElementById('particles-canvas');
        const ctx = canvas.getContext('2d');

        let birds = [];
        const numBirds = 300;
        let mouseX = 0;
        let mouseY = 0;
        
        // Click attraction variables
        let attractionPoint = null;
        let attractionStartTime = 0;
        const attractionDuration = 1000; // 1 second in milliseconds

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Track clicks for bird attraction
        document.addEventListener('click', (e) => {
            // Set attraction point to click location
            attractionPoint = { x: e.clientX, y: e.clientY };
            attractionStartTime = Date.now();
        });

        // Bird class
        class Bird {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.maxSpeed = 2;
                this.maxForce = 0.05;
                this.history = [];
                this.maxHistory = 0;
            }

            update() {
                // Save position history for trail
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }

                // Boid rules: compute steering forces
                let separation = this.separate(); // steer to avoid crowding
                let alignment = this.align();     // steer towards average heading
                let cohesion = this.cohere();     // steer towards center of mass
                let mouse = this.avoidMouse();    // steer away from mouse
                let attraction = this.attractToPoint(); // steer towards click point
                let rotation = this.getRotationalForce(); // rotational force around center
                let centripetal = this.getCentripetalForce(); // force toward center

                // Weights for each behavior
                const sepWeight = 2;
                const aliWeight = 1.0;
                const cohWeight = 1.0;
                const mouseWeight = 10.0;
                const attractionWeight = 10.0; // Strong attraction to click point
                const rotationWeight = 0.01; // adjust for desired effect
                const centripetalWeight = 0.02; // adjust for desired effect

                // Sum weighted steering forces
                let steerX = separation.x * sepWeight + alignment.x * aliWeight + cohesion.x * cohWeight + mouse.x * mouseWeight + attraction.x * attractionWeight + rotation.x * rotationWeight + centripetal.x * centripetalWeight;
                let steerY = separation.y * sepWeight + alignment.y * aliWeight + cohesion.y * cohWeight + mouse.y * mouseWeight + attraction.y * attractionWeight + rotation.y * rotationWeight + centripetal.y * centripetalWeight;

                // Limit total steering force
                let steerMag = Math.hypot(steerX, steerY);
                if (steerMag > this.maxForce) {
                    steerX = (steerX / steerMag) * this.maxForce;
                    steerY = (steerY / steerMag) * this.maxForce;
                }

                // Apply steering to velocity
                this.vx += steerX;
                this.vy += steerY;

                // Limit speed
                let speed = Math.hypot(this.vx, this.vy);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Periodic boundaries - wrap around edges
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            align() {
                let perceptionRadius = 80;
                let avgVx = 0;
                let avgVy = 0;
                let count = 0;

                for (let other of birds) {
                    let d = Math.hypot(other.x - this.x, other.y - this.y);
                    if (other !== this && d < perceptionRadius) {
                        avgVx += other.vx;
                        avgVy += other.vy;
                        count++;
                    }
                }

                if (count > 0) {
                    avgVx /= count;
                    avgVy /= count;
                    avgVx -= this.vx;
                    avgVy -= this.vy;
                    let mag = Math.hypot(avgVx, avgVy);
                    if (mag > this.maxForce) {
                        avgVx = (avgVx / mag) * this.maxForce;
                        avgVy = (avgVy / mag) * this.maxForce;
                    }
                }

                return { x: avgVx, y: avgVy };
            }

            cohere() {
                let perceptionRadius = 80;
                let avgX = 0;
                let avgY = 0;
                let count = 0;

                for (let other of birds) {
                    let d = Math.hypot(other.x - this.x, other.y - this.y);
                    if (other !== this && d < perceptionRadius) {
                        avgX += other.x;
                        avgY += other.y;
                        count++;
                    }
                }

                if (count > 0) {
                    avgX /= count;
                    avgY /= count;
                    avgX -= this.x;
                    avgY -= this.y;
                    let mag = Math.hypot(avgX, avgY);
                    if (mag > this.maxForce) {
                        avgX = (avgX / mag) * this.maxForce;
                        avgY = (avgY / mag) * this.maxForce;
                    }
                }

                return { x: avgX, y: avgY };
            }

            separate() {
                let perceptionRadius = 40;
                let avgX = 0;
                let avgY = 0;
                let count = 0;

                for (let other of birds) {
                    let d = Math.hypot(other.x - this.x, other.y - this.y);
                    if (other !== this && d < perceptionRadius && d > 0) {
                        let diffX = this.x - other.x;
                        let diffY = this.y - other.y;
                        diffX /= d;
                        diffY /= d;
                        avgX += diffX;
                        avgY += diffY;
                        count++;
                    }
                }

                if (count > 0) {
                    avgX /= count;
                    avgY /= count;
                    let mag = Math.hypot(avgX, avgY);
                    if (mag > this.maxForce) {
                        avgX = (avgX / mag) * this.maxForce;
                        avgY = (avgY / mag) * this.maxForce;
                    }
                }

                return { x: avgX, y: avgY };
            }

            avoidMouse() {
                let dx = this.x - mouseX;
                let dy = this.y - mouseY;
                let d = Math.hypot(dx, dy);
                if (d < 100 && d > 0) {
                    dx /= d;
                    dy /= d;
                    return { x: dx * 0.1, y: dy * 0.1 };
                }
                return { x: 0, y: 0 };
            }

            attractToPoint() {
                // Check if attraction is active
                if (!attractionPoint || (Date.now() - attractionStartTime) > attractionDuration) {
                    return { x: 0, y: 0 };
                }

                // Calculate attraction force towards the click point
                let dx = attractionPoint.x - this.x;
                let dy = attractionPoint.y - this.y;
                let d = Math.hypot(dx, dy);
                
                if (d > 0) {
                    // Normalize and apply attraction force
                    dx /= d;
                    dy /= d;
                    
                    // Stronger attraction force than mouse avoidance
                    let strength = 0.3;
                    
                    // Smooth fade attraction over time using a quadratic easing
                    let progress = (Date.now() - attractionStartTime) / attractionDuration;
                    let timeFactor = 1 - (progress * progress); // Quadratic easing out

                    // // Optional: linear fade attraction over time
                    // let timeFactor = 1 - (Date.now() - attractionStartTime) / attractionDuration;
                    strength *= timeFactor;
                    
                    return { x: dx * strength, y: dy * strength };
                }
                
                return { x: 0, y: 0 };
            }

            getRotationalForce() {
                // Calculate a force perpendicular to the vector from center to bird (for counterclockwise rotation)
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                let dx = this.x - centerX;
                let dy = this.y - centerY;
                // Perpendicular vector (for 2D: (dx, dy) -> (-dy, dx) for CCW)
                let perpX = -dy;
                let perpY = dx;
                // Normalize
                let mag = Math.hypot(perpX, perpY);
                if (mag > 0) {
                    perpX /= mag;
                    perpY /= mag;
                }
                // Scale by distance from center (optional: could be constant)
                return { x: perpX, y: perpY };
            }

            getCentripetalForce() {
                // Vector from bird to center
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                let dx = centerX - this.x;
                let dy = centerY - this.y;
                // Normalize
                let mag = Math.hypot(dx, dy);
                if (mag > 0) {
                    dx /= mag;
                    dy /= mag;
                }
                return { x: dx, y: dy };
            }

            draw() {
                // Draw bird as a small triangle pointing in direction of movement
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));
                
                ctx.beginPath();
                ctx.moveTo(6, 0);
                ctx.lineTo(-3, -2);
                ctx.lineTo(-3, 2);
                ctx.closePath();
                
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--particle-color');
                ctx.fill();
                
                ctx.restore();

                // Draw trail
                if (this.history.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.history[0].x, this.history[0].y);
                    
                    for (let i = 1; i < this.history.length; i++) {
                        ctx.lineTo(this.history[i].x, this.history[i].y);
                    }
                    
                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--particle-color');
                    ctx.lineWidth = 0.5;
                    ctx.globalAlpha = 0.2;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
        }

        // Initialize birds
        for (let i = 0; i < numBirds; i++) {
            birds.push(new Bird());
        }

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let bird of birds) {
                bird.update();
                bird.draw();
            }

            requestAnimationFrame(animate);
        }

        animate();

        // Load and parse publications from BibTeX file
        async function loadPublications() {
            try {
                const response = await fetch('publications.bib');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const bibText = await response.text();
                console.log('BibTeX content:', bibText);
                const publications = parseBibTeX(bibText);
                renderPublications(publications);
            } catch (error) {
                console.error('Error loading publications:', error);
                document.getElementById('publications-list').innerHTML = 
                    `<div style="text-align: center; color: var(--text-secondary); padding: 2rem;">Unable to load publications: ${error.message}</div>`;
            }
        }

        // Simple BibTeX parser
        function parseBibTeX(bibText) {
            const entries = [];
            const entryRegex = /@(\w+)\s*\{\s*([^,\s]+)\s*,?\s*([\s\S]*?)(?=\n@|\n\s*$|$)/g;
            
            let match;
            while ((match = entryRegex.exec(bibText)) !== null) {
                const [, type, key, content] = match;
                const entry = { type: type.toLowerCase(), key: key.trim() };
                
                // Parse fields - handle both {value} and value formats
                const fieldRegex = /(\w+)\s*=\s*(\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}|([^,\n}]+))/g;
                let fieldMatch;
                while ((fieldMatch = fieldRegex.exec(content)) !== null) {
                    const [, fieldName, , bracedValue, unbracedValue] = fieldMatch;
                    let fieldValue = (bracedValue !== undefined ? bracedValue : unbracedValue);
                    if (fieldValue) {
                        fieldValue = fieldValue.trim();
                        // Remove trailing commas
                        fieldValue = fieldValue.replace(/,$/, '');
                        entry[fieldName.toLowerCase()] = fieldValue;
                    }
                }
                
                entries.push(entry);
            }
            
            return entries;
        }

        // Render publications
        function renderPublications(publications) {
            const container = document.getElementById('publications-list');
            
            // Separate published papers and preprints
            const published = [];
            const preprints = [];
            
            publications.forEach(pub => {
                const isPreprint = pub.journal?.toLowerCase().includes('arxiv') || 
                                 pub.journal?.toLowerCase().includes('biorxiv') ||
                                 (pub.eprint && (pub.archiveprefix?.toLowerCase() === 'arxiv' || pub.archivePrefix?.toLowerCase() === 'arxiv'));
                
                if (isPreprint) {
                    preprints.push(pub);
                } else {
                    published.push(pub);
                }
            });
            
            let html = '';
            
            // Render published papers
            published.forEach(pub => {
                html += renderPublication(pub);
            });
            
            // Add preprints section if any exist
            if (preprints.length > 0) {
                html += '<h2 style="margin-top: 1rem;">Preprints</h2>';
                preprints.forEach(pub => {
                    html += renderPublication(pub);
                });
            }
            
            container.innerHTML = html;
        }

        // Convert LaTeX accents to Unicode
        function convertLatexAccents(text) {
            let result = text;
            
            // Handle the format {\'\i}k -> ík (accent command followed by letter)
            const accentPatterns = [
                // Acute accents
                [/\{\\'([aeiouynslzcAEIOUYNSLZC])\}/g, (match, letter) => {
                    const map = {'a':'á','e':'é','i':'í','o':'ó','u':'ú','y':'ý','n':'ń','s':'ś','l':'ĺ','z':'ź','c':'ć',
                                'A':'Á','E':'É','I':'Í','O':'Ó','U':'Ú','Y':'Ý','N':'Ń','S':'Ś','L':'Ĺ','Z':'Ź','C':'Ć'};
                    return map[letter] || letter;
                }],
                // Handle \i specifically (dotless i)
                [/\{\\'\\i\}/g, 'í'],
                [/\{\\'\\I\}/g, 'Í'],
                
                // Grave accents
                [/\{\\`([aeiouAEIOU])\}/g, (match, letter) => {
                    const map = {'a':'à','e':'è','i':'ì','o':'ò','u':'ù','A':'À','E':'È','I':'Ì','O':'Ò','U':'Ù'};
                    return map[letter] || letter;
                }],
                
                // Circumflex
                [/\{\\\^([aeiouAEIOU])\}/g, (match, letter) => {
                    const map = {'a':'â','e':'ê','i':'î','o':'ô','u':'û','A':'Â','E':'Ê','I':'Î','O':'Ô','U':'Û'};
                    return map[letter] || letter;
                }],
                
                // Umlaut/diaeresis
                [/\{\\\"([aeiouAEIOU])\}/g, (match, letter) => {
                    const map = {'a':'ä','e':'ë','i':'ï','o':'ö','u':'ü','A':'Ä','E':'Ë','I':'Ï','O':'Ö','U':'Ü'};
                    return map[letter] || letter;
                }],
                
                // Tilde
                [/\{\\~([anoANO])\}/g, (match, letter) => {
                    const map = {'a':'ã','n':'ñ','o':'õ','A':'Ã','N':'Ñ','O':'Õ'};
                    return map[letter] || letter;
                }],
                
                // Cedilla
                [/\{\\c\{([cC])\}\}/g, (match, letter) => letter === 'c' ? 'ç' : 'Ç'],
                
                // Special cases
                [/\{\\aa\}/g, 'å'],
                [/\{\\AA\}/g, 'Å'],
                [/\{\\o\}/g, 'ø'],
                [/\{\\O\}/g, 'Ø'],
                [/\{\\ae\}/g, 'æ'],
                [/\{\\AE\}/g, 'Æ'],
                [/\{\\oe\}/g, 'œ'],
                [/\{\\OE\}/g, 'Œ'],
                [/\{\\ss\}/g, 'ß'],
                [/\{\\l\}/g, 'ł'],
                [/\{\\L\}/g, 'Ł']
            ];
            
            for (const [pattern, replacement] of accentPatterns) {
                result = result.replace(pattern, replacement);
            }
            
            return result;
        }

        // Normalize author name format to "First Last"
        function normalizeAuthorName(author) {
            author = author.trim();
            
            // Check if it's in "Last, First" format
            if (author.includes(',')) {
                const parts = author.split(',').map(part => part.trim());
                if (parts.length === 2) {
                    // Convert "Last, First" to "First Last"
                    return `${parts[1]} ${parts[0]}`;
                }
            }
            
            // Already in "First Last" format or single name
            return author;
        }

        // Format author list with commas
        function formatAuthors(authorString) {
            // Split authors by " and " and rejoin with commas
            let authors = authorString.split(' and ');
            
            // Clean up and normalize each author name
            authors = authors.map(author => normalizeAuthorName(author));
            
            // Join with commas, using "and" before the last author if more than 2 authors
            if (authors.length === 1) {
                return authors[0];
            } else if (authors.length === 2) {
                return authors.join(' and ');
            } else {
                const lastAuthor = authors.pop();
                return authors.join(', ') + ', and ' + lastAuthor;
            }
        }

        // Parse equal contribution info from note field
        function getEqualContributors(noteField) {
            if (!noteField) return [];
            
            // Look for patterns like "equal-contribution: Author1, Author2" or "equal contribution: Author1 and Author2"
            const equalContribRegex = /equal[- ]contribution:\s*([^;.]+)/i;
            const match = noteField.match(equalContribRegex);
            
            if (match) {
                // Split by "and" or commas and clean up
                return match[1]
                    .split(/\s+and\s+|,/)
                    .map(name => name.trim())
                    .filter(name => name.length > 0);
            }
            
            return [];
        }

        // Add asterisks to equal contributors
        function markEqualContributors(authorString, equalContributors) {
            if (equalContributors.length === 0) return authorString;
            
            let result = authorString;
            equalContributors.forEach(contributor => {
                // Create regex that matches the contributor name
                const escapedName = contributor.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`\\b${escapedName}\\b`, 'gi');
                result = result.replace(regex, `${contributor}*`);
            });
            
            return result;
        }

        // Make your name bold in author lists
        function boldMyName(authorString) {
            // Handle various formats of your name
            const nameVariations = [
                'Luca Baroni',
                'L. Baroni',
                'Baroni, L.',
                'Baroni, Luca',
                'Baroni L.',
                'Baroni L'
            ];
            
            let result = authorString;
            nameVariations.forEach(name => {
                // Create regex that matches the name with word boundaries - handle asterisks
                const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`\\b${escapedName}(\\*?)\\b`, 'gi');
                result = result.replace(regex, `<span style="font-weight: 900;">${name}$1</span>`);
            });
            
            return result;
        }

        // Render individual publication
        function renderPublication(pub) {
            const title = convertLatexAccents(pub.title || 'Untitled');
            const rawAuthors = convertLatexAccents(pub.author || 'Unknown authors');
            const formattedAuthors = formatAuthors(rawAuthors);
            
            // Handle equal contribution from note field
            const equalContributors = getEqualContributors(pub.note);
            const authorsWithAsterisks = markEqualContributors(formattedAuthors, equalContributors);
            const authors = boldMyName(authorsWithAsterisks);
            
            const venue = convertLatexAccents(getVenue(pub));
            const mainUrl = getMainUrl(pub);
            
            // Make the entire div clickable if there's a URL
            const clickableAttributes = mainUrl ? 
                `onclick="window.open('${mainUrl}', '_blank')" style="cursor: pointer;"` : '';
            
            // Venue and equal contribution note in a flex row
            let venueRow = '';
            if (venue || equalContributors.length > 0) {
                venueRow = `<div class="publication-venue-row">
                    ${venue ? `<div class=\"publication-venue\">${venue}</div>` : ''}
                    ${equalContributors.length > 0 ? `<div class=\"publication-equal-note\">*equal contribution</div>` : ''}
                </div>`;
            }
            
            return `
                <div class="publication" ${clickableAttributes}>
                    <div class="publication-title">${title}</div>
                    <div class="publication-authors">${authors}</div>
                    ${venueRow}
                </div>
            `;
        }

        // Get venue information
        function getVenue(pub) {
            let venue = '';
            
            // Handle arXiv and bioRxiv as preprints
            // Note: field names are converted to lowercase by the parser
            if (pub.journal?.toLowerCase().includes('arxiv') || 
                (pub.eprint && (pub.archiveprefix?.toLowerCase() === 'arxiv' || pub.archivePrefix?.toLowerCase() === 'arxiv'))) {
                venue = `arXiv preprint${pub.year ? `, ${pub.year}` : ''}`;
            } else if (pub.journal?.toLowerCase().includes('biorxiv') || pub.publisher?.toLowerCase().includes('biorxiv')) {
                venue = `bioRxiv preprint${pub.year ? `, ${pub.year}` : ''}`;
            } else if (pub.journal) {
                venue = `${pub.journal}${pub.year ? `, ${pub.year}` : ''}`;
            } else if (pub.booktitle) {
                venue = `${pub.booktitle}${pub.year ? `, ${pub.year}` : ''}`;
            } else if (pub.school) {
                venue = `${pub.school}${pub.year ? `, ${pub.year}` : ''}`;
            } else {
                venue = pub.year || '';
            }
            
            // Add presentation type if available (but not for preprints since they don't have presentations)
            if (pub.presentation && pub.presentation.trim() && !venue.includes('preprint')) {
                venue += ` (${pub.presentation.toUpperCase()})`;
            }
            
            return venue;
        }

        // Get main publication URL
        function getMainUrl(pub) {
            if (pub.url) {
                return pub.url;
            } else if (pub.doi) {
                return `https://doi.org/${pub.doi}`;
            } else if (pub.eprint && (pub.archiveprefix?.toLowerCase() === 'arxiv' || pub.archivePrefix?.toLowerCase() === 'arxiv')) {
                return `https://arxiv.org/abs/${pub.eprint}`;
            }
            return null;
        }

        // Load publications when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadPublications();
        });
    </script>
</body>
</html>